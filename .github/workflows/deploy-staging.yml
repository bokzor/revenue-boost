name: ðŸš€ Deploy to Staging

on:
  # Automatically deploy when PRs are merged to develop
  push:
    branches:
      - develop
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'website/**'
      - '.github/workflows/deploy-production.yml'
      - '.github/workflows/deploy-extensions-production.yml'
      - '.github/workflows/deploy-website.yml'

  # Manual trigger for ad-hoc deployments
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests (for quick deployments)'
        required: false
        default: false
        type: boolean
      run_e2e_tests:
        description: 'Run E2E tests after deployment'
        required: false
        default: false
        type: boolean

# Automatically cancel previous runs when new ones start
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  PROJECT_ID: revenueboost-staging
  REGION: us-central1
  SERVICE_NAME: revenueboost-staging
  NODE_VERSION: '24'

jobs:
  # Check if self-hosted runner is available for tests
  check-runner:
    name: ðŸ” Check Runner
    if: ${{ !inputs.skip_tests }}
    uses: ./.github/workflows/check-runner.yml
    with:
      runner_labels: 'self-hosted'

  # Run tests using reusable workflow
  tests:
    name: ðŸ§ª Tests
    needs: check-runner
    if: ${{ !inputs.skip_tests }}
    uses: ./.github/workflows/reusable-tests.yml
    with:
      runner: ${{ needs.check-runner.outputs.runner }}
      run_unit_tests: true
      run_integration_tests: true
      run_lint: true
      run_typecheck: true
      node_version: '24'

  deploy:
    name: ðŸš€ Deploy to Staging
    needs: [tests]
    if: always() && (needs.tests.result == 'success' || needs.tests.result == 'skipped')
    runs-on: ubuntu-latest
    environment: staging
    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ðŸ”§ Install dependencies
        run: npm ci

      - name: ðŸ—ï¸ Build application
        run: npm run build

      - name: ðŸ” Authenticate to Google Cloud
        id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_SA_KEY }}'

      - name: â˜ï¸ Setup gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: 'latest'

      - name: ðŸ³ Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev

      - name: ðŸ”¨ Build and push Docker image
        run: |
          # Ensure Artifact Registry repository exists (one-time manual setup in GCP console)
          gcloud artifacts repositories describe ${{ env.SERVICE_NAME }} \
            --location=${{ env.REGION }} \
            >/dev/null 2>&1 || {
              echo "âŒ Artifact Registry repository '${{ env.SERVICE_NAME }}' not found in project '${{ env.PROJECT_ID }}'." >&2
              echo "   Create it once via GCP Console â†’ Artifact Registry â†’ Create repository (type: Docker, name: '${{ env.SERVICE_NAME }}', location: '${{ env.REGION }}')." >&2
              exit 1
            }

          # Build with staging mode (minified but with console.log and sourcemaps)
          docker build \
            --build-arg BUILD_MODE=staging \
            -t ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}/${{ env.SERVICE_NAME }}:${{ github.sha }} .
          docker tag ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}/${{ env.SERVICE_NAME }}:${{ github.sha }} ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}/${{ env.SERVICE_NAME }}:latest
          docker push ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}/${{ env.SERVICE_NAME }}:${{ github.sha }}
          docker push ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}/${{ env.SERVICE_NAME }}:latest

      - name: ðŸš€ Deploy to Cloud Run
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
          INTERNAL_API_SECRET: ${{ secrets.INTERNAL_API_SECRET }}
        run: |
          # Debug: Check if secrets are available (without exposing values)
          echo "ðŸ” Checking secrets availability..."
          echo "DATABASE_URL length: ${#DATABASE_URL}"
          echo "REDIS_URL length: ${#REDIS_URL}"
          echo "SESSION_SECRET length: ${#SESSION_SECRET}"
          echo "INTERNAL_API_SECRET length: ${#INTERNAL_API_SECRET}"

          # Validate that we have real secrets, not placeholders
          if [[ "$DATABASE_URL" == *"username:password"* ]]; then
            echo "âŒ DATABASE_URL contains placeholder values!"
            exit 1
          fi

          # Get the service URL first (or use temporary URL for initial deployment)
          # For initial deployment, use a temporary URL that will be updated after service is created
          SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region ${{ env.REGION }} \
            --format 'value(status.url)' 2>/dev/null || echo "")

          # If SERVICE_URL is empty, use temporary URL
          if [[ -z "$SERVICE_URL" ]]; then
            SERVICE_URL="https://temp-deployment.run.app"
            echo "âš ï¸  Initial deployment detected - service will need URL update after creation"
          fi

          echo "ðŸ“ Using SHOPIFY_APP_URL: $SERVICE_URL"

          # Create environment variables file to avoid shell escaping issues
          cat > env_vars.yaml << EOF
          NODE_ENV: production
          DATABASE_URL: "${{ secrets.DATABASE_URL }}"
          REDIS_URL: "${{ secrets.REDIS_URL }}"
          SESSION_SECRET: "${{ secrets.SESSION_SECRET }}"
          SHOPIFY_APP_URL: "$SERVICE_URL"
          SHOPIFY_API_KEY: "${{ secrets.SHOPIFY_API_KEY }}"
          SHOPIFY_API_SECRET: "${{ secrets.SHOPIFY_API_SECRET }}"
          SCOPES: "write_products,write_customers,read_orders,write_script_tags,read_themes,write_discounts"
          SHOPIFY_SCOPES: "write_products,write_customers,read_orders,write_script_tags,read_themes,write_discounts"
          INTERNAL_API_SECRET: "${{ secrets.INTERNAL_API_SECRET }}"
          BILLING_BYPASS: "true"
          RATE_LIMIT_BYPASS: "true"
          EOF

          gcloud run deploy ${{ env.SERVICE_NAME }} \
            --image ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}/${{ env.SERVICE_NAME }}:latest \
            --region ${{ env.REGION }} \
            --platform managed \
            --allow-unauthenticated \
            --memory 1Gi \
            --cpu 1 \
            --min-instances 0 \
            --max-instances 3 \
            --timeout 300 \
            --port 3000 \
            --env-vars-file env_vars.yaml

      - name: ðŸŒ Get service URL
        id: 'service-url'
        run: |
          SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region ${{ env.REGION }} \
            --format 'value(status.url)')
          echo "url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "SERVICE_URL=$SERVICE_URL" >> $GITHUB_ENV

      - name: ðŸ”„ Update service with real URL (if initial deployment)
        run: |
          # Check if we used the temporary URL
          CURRENT_APP_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region ${{ env.REGION }} \
            --format 'value(spec.template.spec.containers[0].env[?(@.name=="SHOPIFY_APP_URL")].value)')

          if [[ "$CURRENT_APP_URL" == "https://temp-deployment.run.app" ]]; then
            echo "ðŸ”„ Updating service with real URL: ${{ steps.service-url.outputs.url }}"

            # Update the env_vars.yaml with the real URL
            cat > env_vars.yaml << EOF
          NODE_ENV: production
          DATABASE_URL: "${{ secrets.DATABASE_URL }}"
          REDIS_URL: "${{ secrets.REDIS_URL }}"
          SESSION_SECRET: "${{ secrets.SESSION_SECRET }}"
          SHOPIFY_APP_URL: "${{ steps.service-url.outputs.url }}"
          SHOPIFY_API_KEY: "${{ secrets.SHOPIFY_API_KEY }}"
          SHOPIFY_API_SECRET: "${{ secrets.SHOPIFY_API_SECRET }}"
          SCOPES: "write_products,write_customers,read_orders,write_script_tags,read_themes,write_discounts"
          SHOPIFY_SCOPES: "write_products,write_customers,read_orders,write_script_tags,read_themes,write_discounts"
          INTERNAL_API_SECRET: "${{ secrets.INTERNAL_API_SECRET }}"
          BILLING_BYPASS: "true"
          RATE_LIMIT_BYPASS: "true"
          EOF

            # Redeploy with the real URL
            gcloud run services update ${{ env.SERVICE_NAME }} \
              --region ${{ env.REGION }} \
              --env-vars-file env_vars.yaml

            echo "âœ… Service updated with real URL"
          else
            echo "âœ… Service already has correct URL: $CURRENT_APP_URL"
          fi

      - name: ðŸ¥ Health check
        run: |
          echo "â³ Waiting for service to be ready..."
          sleep 30
          curl -f ${{ steps.service-url.outputs.url }}/api/health || echo "âš ï¸ Health check failed, but deployment completed"

      - name: ðŸ“‹ Deployment summary
        run: |
          echo "## ðŸŽ‰ Staging Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**ðŸŒ Service URL:** ${{ steps.service-url.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "**ðŸ“… Deployed at:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**ðŸ”– Git SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“ Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Update Shopify Partner Dashboard with new URL" >> $GITHUB_STEP_SUMMARY
          echo "2. Test app installation: \`${{ steps.service-url.outputs.url }}/api/auth?shop=your-store.myshopify.com\`" >> $GITHUB_STEP_SUMMARY
          echo "3. Monitor logs: \`gcloud run services logs read ${{ env.SERVICE_NAME }} --region=${{ env.REGION }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Quick Links:" >> $GITHUB_STEP_SUMMARY
          echo "- [Cloud Run Console](https://console.cloud.google.com/run/detail/${{ env.REGION }}/${{ env.SERVICE_NAME }})" >> $GITHUB_STEP_SUMMARY
          echo "- [Shopify Partners](https://partners.shopify.com/organizations)" >> $GITHUB_STEP_SUMMARY

  # Optional E2E tests after deployment
  e2e-tests:
    name: E2E Staging Tests
    needs: [deploy]
    if: ${{ inputs.run_e2e_tests == true }}
    uses: ./.github/workflows/e2e-staging-tests.yml
    secrets:
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      REDIS_URL: ${{ secrets.REDIS_URL }}
      STORE_PASSWORD: ${{ secrets.STORE_PASSWORD }}
