name: ðŸš€ Deploy to Staging

on:
  # Automatically deploy when PRs are merged to develop
  push:
    branches:
      - develop
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'website/**'
      - '.github/workflows/deploy-production.yml'
      - '.github/workflows/deploy-extensions-production.yml'
      - '.github/workflows/deploy-website.yml'

  # Manual trigger for ad-hoc deployments
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip unit/integration tests (for quick deployments)'
        required: false
        default: false
        type: boolean
      skip_e2e:
        description: 'Skip E2E tests (emergency only - blocks production deploy)'
        required: false
        default: false
        type: boolean

# Automatically cancel previous runs when new ones start
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  PROJECT_ID: revenueboost-staging
  REGION: us-central1
  SERVICE_NAME: revenueboost-staging
  NODE_VERSION: '24'

jobs:
  # Check if self-hosted runner is available for tests
  check-runner:
    name: ðŸ” Check Runner
    if: ${{ !inputs.skip_tests }}
    uses: ./.github/workflows/check-runner.yml
    with:
      runner_labels: 'self-hosted'

  # Run tests using reusable workflow
  tests:
    name: ðŸ§ª Tests
    needs: check-runner
    if: ${{ !inputs.skip_tests }}
    uses: ./.github/workflows/reusable-tests.yml
    with:
      runner: ${{ needs.check-runner.outputs.runner }}
      run_unit_tests: true
      run_integration_tests: true
      run_lint: true
      run_typecheck: true
      node_version: '24'

  deploy:
    name: ðŸš€ Deploy to Staging
    # Run in parallel with tests for faster staging deployments
    # Tests failure will be handled by notify-on-test-failure job
    runs-on: ubuntu-latest
    environment: staging
    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ” Authenticate to Google Cloud
        id: 'auth'
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_SA_KEY }}'

      - name: â˜ï¸ Setup gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          version: 'latest'

      - name: ðŸ³ Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev

      - name: ðŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ðŸ” Check Artifact Registry repository
        run: |
          gcloud artifacts repositories describe ${{ env.SERVICE_NAME }} \
            --location=${{ env.REGION }} \
            >/dev/null 2>&1 || {
              echo "âŒ Artifact Registry repository '${{ env.SERVICE_NAME }}' not found in project '${{ env.PROJECT_ID }}'." >&2
              echo "   Create it once via GCP Console â†’ Artifact Registry â†’ Create repository (type: Docker, name: '${{ env.SERVICE_NAME }}', location: '${{ env.REGION }}')." >&2
              exit 1
            }

      - name: ðŸ”¨ Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}/${{ env.SERVICE_NAME }}:${{ github.sha }}
            ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}/${{ env.SERVICE_NAME }}:latest
          build-args: BUILD_MODE=staging
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: ðŸš€ Deploy to Cloud Run
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
          INTERNAL_API_SECRET: ${{ secrets.INTERNAL_API_SECRET }}
        run: |
          # Debug: Check if secrets are available (without exposing values)
          echo "ðŸ” Checking secrets availability..."
          echo "DATABASE_URL length: ${#DATABASE_URL}"
          echo "REDIS_URL length: ${#REDIS_URL}"
          echo "SESSION_SECRET length: ${#SESSION_SECRET}"
          echo "INTERNAL_API_SECRET length: ${#INTERNAL_API_SECRET}"

          # Validate that we have real secrets, not placeholders
          if [[ "$DATABASE_URL" == *"username:password"* ]]; then
            echo "âŒ DATABASE_URL contains placeholder values!"
            exit 1
          fi

          # Get the service URL first (or use temporary URL for initial deployment)
          # For initial deployment, use a temporary URL that will be updated after service is created
          SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region ${{ env.REGION }} \
            --format 'value(status.url)' 2>/dev/null || echo "")

          # If SERVICE_URL is empty, use temporary URL
          if [[ -z "$SERVICE_URL" ]]; then
            SERVICE_URL="https://temp-deployment.run.app"
            echo "âš ï¸  Initial deployment detected - service will need URL update after creation"
          fi

          echo "ðŸ“ Using SHOPIFY_APP_URL: $SERVICE_URL"

          # Create environment variables file to avoid shell escaping issues
          cat > env_vars.yaml << EOF
          NODE_ENV: production
          DATABASE_URL: "${{ secrets.DATABASE_URL }}"
          REDIS_URL: "${{ secrets.REDIS_URL }}"
          SESSION_SECRET: "${{ secrets.SESSION_SECRET }}"
          SHOPIFY_APP_URL: "$SERVICE_URL"
          SHOPIFY_API_KEY: "${{ secrets.SHOPIFY_API_KEY }}"
          SHOPIFY_API_SECRET: "${{ secrets.SHOPIFY_API_SECRET }}"
          SCOPES: "read_discounts,write_discounts,read_products,read_themes,read_orders,write_marketing_events,read_marketing_events,read_customers,write_customers,write_files"
          SHOPIFY_SCOPES: "read_discounts,write_discounts,read_products,read_themes,read_orders,write_marketing_events,read_marketing_events,read_customers,write_customers,write_files"
          INTERNAL_API_SECRET: "${{ secrets.INTERNAL_API_SECRET }}"
          BILLING_BYPASS: "true"
          RATE_LIMIT_BYPASS: "true"
          EOF

          # Deploy with --no-traffic for zero-downtime (new revision doesn't receive traffic yet)
          gcloud run deploy ${{ env.SERVICE_NAME }} \
            --image ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}/${{ env.SERVICE_NAME }}:latest \
            --region ${{ env.REGION }} \
            --platform managed \
            --allow-unauthenticated \
            --memory 1Gi \
            --cpu 1 \
            --min-instances 0 \
            --max-instances 3 \
            --timeout 300 \
            --port 3000 \
            --no-traffic \
            --env-vars-file env_vars.yaml

      - name: ðŸŒ Get service URL
        id: 'service-url'
        run: |
          SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region ${{ env.REGION }} \
            --format 'value(status.url)')
          echo "url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "SERVICE_URL=$SERVICE_URL" >> $GITHUB_ENV

      - name: ðŸ”„ Update service with real URL (if initial deployment)
        run: |
          # Check if we used the temporary URL
          CURRENT_APP_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region ${{ env.REGION }} \
            --format 'value(spec.template.spec.containers[0].env[?(@.name=="SHOPIFY_APP_URL")].value)')

          if [[ "$CURRENT_APP_URL" == "https://temp-deployment.run.app" ]]; then
            echo "ðŸ”„ Updating service with real URL: ${{ steps.service-url.outputs.url }}"

            # Update the env_vars.yaml with the real URL
            cat > env_vars.yaml << EOF
          NODE_ENV: production
          DATABASE_URL: "${{ secrets.DATABASE_URL }}"
          REDIS_URL: "${{ secrets.REDIS_URL }}"
          SESSION_SECRET: "${{ secrets.SESSION_SECRET }}"
          SHOPIFY_APP_URL: "${{ steps.service-url.outputs.url }}"
          SHOPIFY_API_KEY: "${{ secrets.SHOPIFY_API_KEY }}"
          SHOPIFY_API_SECRET: "${{ secrets.SHOPIFY_API_SECRET }}"
          SCOPES: "read_discounts,write_discounts,read_products,read_themes,read_orders,write_marketing_events,read_marketing_events,read_customers,write_customers,write_files"
          SHOPIFY_SCOPES: "read_discounts,write_discounts,read_products,read_themes,read_orders,write_marketing_events,read_marketing_events,read_customers,write_customers,write_files"
          INTERNAL_API_SECRET: "${{ secrets.INTERNAL_API_SECRET }}"
          BILLING_BYPASS: "true"
          RATE_LIMIT_BYPASS: "true"
          EOF

            # Redeploy with the real URL (also with --no-traffic)
            gcloud run deploy ${{ env.SERVICE_NAME }} \
              --region ${{ env.REGION }} \
              --no-traffic \
              --env-vars-file env_vars.yaml

            echo "âœ… Service updated with real URL"
          else
            echo "âœ… Service already has correct URL: $CURRENT_APP_URL"
          fi

      - name: ðŸ¥ Health check (new revision)
        id: health-check
        run: |
          echo "â³ Checking new revision health..."
          # Get the latest revision URL for health check
          LATEST_REVISION=$(gcloud run revisions list \
            --service=${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --limit=1 \
            --format='value(REVISION)')
          echo "Latest revision: $LATEST_REVISION"

          # Retry health check with shorter intervals
          for i in {1..10}; do
            if curl -sf "${{ steps.service-url.outputs.url }}/api/health" > /dev/null 2>&1; then
              echo "âœ… Health check passed on attempt $i"
              echo "healthy=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Attempt $i/10 failed, retrying in 3s..."
            sleep 3
          done
          echo "âš ï¸ Health check failed after 10 attempts"
          echo "healthy=false" >> $GITHUB_OUTPUT

      - name: ðŸš¦ Shift traffic to new revision
        if: steps.health-check.outputs.healthy == 'true'
        run: |
          echo "ðŸš¦ Shifting 100% traffic to latest revision..."
          gcloud run services update-traffic ${{ env.SERVICE_NAME }} \
            --to-latest \
            --region ${{ env.REGION }}
          echo "âœ… Traffic shifted to new revision"

      - name: âš ï¸ Rollback warning
        if: steps.health-check.outputs.healthy != 'true'
        run: |
          echo "::warning::Health check failed! New revision deployed but NOT receiving traffic."
          echo "Previous revision is still serving requests."
          echo "To manually shift traffic: gcloud run services update-traffic ${{ env.SERVICE_NAME }} --to-latest --region ${{ env.REGION }}"

      - name: ðŸ“‹ Deployment summary
        run: |
          echo "## ðŸŽ‰ Staging Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**ðŸŒ Service URL:** ${{ steps.service-url.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "**ðŸ“… Deployed at:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**ðŸ”– Git SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“ Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Update Shopify Partner Dashboard with new URL" >> $GITHUB_STEP_SUMMARY
          echo "2. Test app installation: \`${{ steps.service-url.outputs.url }}/api/auth?shop=your-store.myshopify.com\`" >> $GITHUB_STEP_SUMMARY
          echo "3. Monitor logs: \`gcloud run services logs read ${{ env.SERVICE_NAME }} --region=${{ env.REGION }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Quick Links:" >> $GITHUB_STEP_SUMMARY
          echo "- [Cloud Run Console](https://console.cloud.google.com/run/detail/${{ env.REGION }}/${{ env.SERVICE_NAME }})" >> $GITHUB_STEP_SUMMARY
          echo "- [Shopify Partners](https://partners.shopify.com/organizations)" >> $GITHUB_STEP_SUMMARY

  # Notify if tests fail (since deploy runs in parallel)
  notify-on-test-failure:
    name: âš ï¸ Test Failure Alert
    needs: [tests, deploy]
    if: always() && needs.tests.result == 'failure'
    runs-on: ubuntu-latest
    steps:
      - name: âš ï¸ Tests failed warning
        run: |
          echo "::warning::Tests FAILED but staging was deployed!"
          echo "## âš ï¸ Tests Failed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Staging was deployed but tests failed." >> $GITHUB_STEP_SUMMARY
          echo "Please investigate and fix the failing tests." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Author:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY

  # =============================================================================
  # E2E TESTS - Required for Production Readiness
  # =============================================================================
  # E2E tests run SEQUENTIALLY after successful staging deploy to avoid
  # interference (both create campaigns on the same staging database/storefront).
  # Results are used to gate production deployments via commit status.
  # =============================================================================

  # E2E Admin & Integration Tests (campaign creation, admin-to-storefront flow)
  # Runs FIRST because it creates campaigns via UI which is slower
  e2e-admin:
    name: ðŸ”§ E2E Admin & Integration Tests
    needs: [deploy]
    if: ${{ success() && inputs.skip_e2e != true }}
    uses: ./.github/workflows/e2e-admin-tests.yml
    with:
      test_suite: 'all'
      test_filter: ''
    secrets:
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      STORE_PASSWORD: ${{ secrets.STORE_PASSWORD }}
      SHOPIFY_API_KEY: ${{ secrets.SHOPIFY_API_KEY }}
      SHOPIFY_API_SECRET: ${{ secrets.SHOPIFY_API_SECRET }}

  # E2E Storefront Tests (popup rendering on real storefront)
  # Runs AFTER admin tests to avoid campaign conflicts on storefront
  # Uses always() to run even if admin tests fail (to get complete test results)
  e2e-storefront:
    name: ðŸ§ª E2E Storefront Tests
    needs: [deploy, e2e-admin]
    if: ${{ always() && needs.deploy.result == 'success' && inputs.skip_e2e != true }}
    uses: ./.github/workflows/e2e-staging-tests.yml
    with:
      test_filter: ''
    secrets:
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      REDIS_URL: ${{ secrets.REDIS_URL }}
      STORE_PASSWORD: ${{ secrets.STORE_PASSWORD }}
      SHOPIFY_API_KEY: ${{ secrets.SHOPIFY_API_KEY }}
      SHOPIFY_API_SECRET: ${{ secrets.SHOPIFY_API_SECRET }}

  # Update commit status based on E2E results (gates production deploys)
  update-e2e-status:
    name: ðŸ“Š Update E2E Status
    needs: [e2e-storefront, e2e-admin]
    if: always() && inputs.skip_e2e != true
    runs-on: ubuntu-latest
    permissions:
      statuses: write
    steps:
      - name: Set E2E status check
        uses: actions/github-script@v7
        with:
          script: |
            const storefrontResult = '${{ needs.e2e-storefront.result }}';
            const adminResult = '${{ needs.e2e-admin.result }}';

            const allPassed = storefrontResult === 'success' && adminResult === 'success';
            const state = allPassed ? 'success' : 'failure';

            let description;
            if (allPassed) {
              description = 'All E2E tests passed - ready for production';
            } else {
              const failures = [];
              if (storefrontResult !== 'success') failures.push('storefront');
              if (adminResult !== 'success') failures.push('admin');
              description = `E2E tests failed (${failures.join(', ')}) - do not merge to main`;
            }

            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: state,
              context: 'e2e/staging',
              description: description,
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            });

            console.log(`Set e2e/staging status to ${state} for ${context.sha}`);
            console.log(`  Storefront: ${storefrontResult}`);
            console.log(`  Admin: ${adminResult}`);

      - name: ðŸ“‹ E2E Summary
        if: always()
        run: |
          echo "## ðŸ§ª E2E Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Test Suite | Result |" >> $GITHUB_STEP_SUMMARY
          echo "|------------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Storefront E2E | ${{ needs.e2e-storefront.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Admin & Integration E2E | ${{ needs.e2e-admin.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.e2e-storefront.result }}" == "success" && "${{ needs.e2e-admin.result }}" == "success" ]]; then
            echo "### âœ… Production Ready" >> $GITHUB_STEP_SUMMARY
            echo "All E2E tests passed. This commit can be merged to \`main\` for production deployment." >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ Not Production Ready" >> $GITHUB_STEP_SUMMARY
            echo "E2E tests failed. Fix the issues before merging to \`main\`." >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**ðŸ“… Tested at:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**ðŸ”– Git SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

  # Set skipped status when E2E is bypassed (for visibility)
  update-e2e-status-skipped:
    name: ðŸ“Š Update E2E Status (Skipped)
    needs: [deploy]
    if: ${{ success() && inputs.skip_e2e == true }}
    runs-on: ubuntu-latest
    permissions:
      statuses: write
    steps:
      - name: Set E2E status as pending
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: 'pending',
              context: 'e2e/staging',
              description: 'E2E tests skipped - manual trigger required before production',
              target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            });

            console.log(`Set e2e/staging status to pending (skipped) for ${context.sha}`);
